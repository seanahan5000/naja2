
                EXP OFF

; slightly different name to avoid COMMON/VARS version
SAME_PAGE_AS_   MAC
                ERR *!]1/256
                EOM

*==================================
*
* NDOS (Naja Disk Operating System)
*    for 5.25 inch Disk ][ disks
*
*==================================

STRACK			=	$B1
SSTOREH			=	$B2
DISK_SIDE		=	$B3

FILES			=	$B4
FILESH			=	$B5

MOTCNTL			=	$B8
MOTCNTH			=	$B9
HOLDA			=	$BA
HOLDB			=	$BB
HOLDD			=	$BC
DESTL			=	$BD
DESTH			=	$BE
*

PTR1			=	MOTCNTL			;and PTR1+1

BUFFER1			=	$0200
BUFFER2			=	$0300

ARM				=	$C080
DRIVOFF			=	$C088
DRIVEON			=	$C089
DRIVE1			=	$C08A
READER			=	$C08C
LATCHIN			=	$C08E

D_HEAD1			=	$D5
D_HEAD2			=	$AA
D_HEAD3			=	$AD

RECALIBS		=	1
RETRIES			=	20

; TODO: get rid of these
DRIVE_ON        ENT
                JMP UP_TO_SPEED
DRIVE_OFF       ENT
                JMP TURN_OFF

; TODO: are these still valid?
;
* SIDE_FOUND:
*    0 = BOOT, 1 = UNUSED
*    2 = TRACC 17,15,  3 = TRACC 13,11,9
*    4 = FIGHT 17,15,  5 = FIGHT 13,11,9

READ_ADDRESS	LDX	SLOT_X0
				LDY	#$F0
				STY	HOLDA
:RETRY1			INY
				BNE	:1
				INC	HOLDA
				BEQ	:ERROR

:1				LDA	READER,X
				BPL	:1
:RETRY2			CMP	#$D5
				BNE	:RETRY1
				NOP

:2				LDA	READER,X
				BPL	:2
				CMP	#$AA
				BNE	:RETRY2
				LDY	#3

:3				LDA	READER,X
				BPL	:3
				CMP	#$96
				BNE	:RETRY2

				LDA	#$00
:4				STA	HOLDB			; clear checksum
:5				LDA	READER,X
				BPL	:5
				ROL					; carry set
				STA	HOLDA
:6				LDA	READER,X
				BPL	:6
				AND	HOLDA
				STA	CHECKSUM_FOUND,Y
				EOR	HOLDB			; update checksum
				DEY
				BPL	:4
				TAY
				BNE	:ERROR			; bad checksum

:7				LDA	READER,X
				BPL	:7
				CMP	#$DE
				BNE	:ERROR
				NOP

:8				LDA	READER,X
				BPL	:8
				CMP	#$AA
				BNE	:ERROR

				LDX	SECTOR_FOUND
				LDA	INTERLEAVE_P2L,X
				EOR	SECTOR
				BMI	:SUCCESS		; don't care which sector
				BNE	READ_ADDRESS
:SUCCESS		CLC
				RTS

:ERROR			SEC
				RTS

READ_DATA		LDX	SLOT_X0
				LDY	#$20
ERRCNT			DEY
				BEQ	ERROR2
LOOP1			LDA	READER,X
				BPL	LOOP1
CHECK1			EOR	#D_HEAD1
				BNE	ERRCNT
				NOP
LOOP2			LDA	READER,X
				BPL	LOOP2
				CMP	#D_HEAD2
				BNE	CHECK1
				LDY	#$56
LOOP3			LDA	READER,X
				BPL	LOOP3
				CMP	#D_HEAD3
				BNE	CHECK1
				LDA	#$00
CHECK2			DEY
				STY	HOLDA
LOOP4			LDY	READER,X
				BPL	LOOP4
				EOR	CODETAB,Y
				LDY	HOLDA
				STA	BUFFER2,Y
				BNE	CHECK2
CHECK3			STY	HOLDA
LOOP5			LDY	READER,X
				BPL	LOOP5
				EOR	CODETAB,Y
				LDY	HOLDA
				STA	BUFFER1,Y
				INY
				BNE	CHECK3
LOOP6			LDY	READER,X
				BPL	LOOP6
				CMP	CODETAB,Y
				BNE	ERROR2
				CLC
				RTS
ERROR2			SEC
				RTS


DENIBLR         LDY	#$00
:LOOP1			LDX	#$56
:LOOP2			DEX
				BMI	:LOOP1
				LDA	BUFFER1,Y
				LSR	BUFFER2,X
				ROL
				LSR	BUFFER2,X
				ROL
				STA	(PTR1),Y
				INY
				CPY	HOLDA
				BNE	:LOOP2
				SAME_PAGE_AS_ :LOOP1
				RTS


                DS  17                  ;*** FREE SPACE

********************************
* A = NUMBER OF SECTORS TO READ
* X = BEGINNING SECTOR LOW
* Y = BEGINNING SECTOR HIGH
* SIDE = 0,1,2,3 OR 4
* SSTOREL = DESTINATION ADDRESS (LOW)
* SSTOREH = DESTINATION ADDRESS (HIGH)

READ_SECTORS
*SEI
				NOP					;Remove when SEI put in

				BIT	ON_OFF_FLAG
				BMI	:LOOP1
				JSR	GET_SLOW_SIDE
				JMP	:SKIPA
:LOOP1			JSR	GET_FAST_SIDE
:SKIPA			LDA	SSTOREL
				STA	DESTL
				LDA	SSTOREH
				STA	DESTH
				LDA	SECHOLD
				STA	SECTOR
:LOOP3			LDA	#RETRIES
				STA	ECOUNT2
:LOOP2			JSR	READ_ADDRESS
				BCS	:ERROR
				JSR	READ_DATA
				BCC	:SKIPC
:ERROR			DEC	ECOUNT2
				BNE	:LOOP2
				LDA	#$88
				STA	TRACK
				LDA	#$00
				JSR	ARMOVE
				JMP	:LOOP1
:SKIPC			LDA	DESTL
				STA	PTR1
				LDA	DESTH
				BEQ	:SKIPE
				STA	PTR1+1
				LDX	#$00
				LDA	SECOUNT
				CMP	#$01
				BNE	:SKIPD
				LDX	LAST1
:SKIPD			STX	HOLDA
				JSR	DENIBLR
:SKIPE			INC	DESTH
				INC	SECTOR
				DEC	SECOUNT
				BEQ	READ_DONE
				LDA	SECTOR
				CMP	#$10
				BNE	:LOOP3
				LDA	#$00
				STA	SECTOR
				LDA	TRACK
				CLC
				ADC	#$02
				JSR	ARMOVE
				JMP	:LOOP3
READ_DONE

				BIT	ON_OFF_FLAG
				BVS	RETURN
TURN_OFF		LDX	SLOT_X0
				STA	DRIVOFF,X
RETURN			RTS

CHECK_WRITPRO	ENT
				JSR	GET_FAST_SIDE	;This routine assumes that
:LOOP1			LDX	SLOT_X0			;   drive is up to speed on entry
				LDA	$C08D,X
				LDA	LATCHIN,X
				BPL	RETURN
				STA	DRIVOFF,X
				JSR	UN_WRITE_PRO
				JSR	GET_SLOW_SIDE
				JMP	:LOOP1

GET_FAST_SIDE	JSR	FIND_SIDE
				CMP	DISK_SIDE
				BEQ	GOT_THE_SIDE
				JSR	TURN_OFF

GET_SLOW_SIDE	LDX	#0
				LDA	IN_DRIVE1
				CMP	DISK_SIDE
				BEQ	:SKIPA
				LDA	NUM_DRIVES
				BEQ	:SKIPA
				LDA	IN_DRIVE2
				CMP	DISK_SIDE
				BNE	:SKIPA
				INX
:SKIPA			JSR	SLOW_SIDE
				BEQ	GOT_THE_SIDE
				LDA	NUM_DRIVES
				BEQ	:SKIPB
				JSR	TURN_OFF
				LDA	DRIVENUM
				EOR	#$01
				TAX
				JSR	SLOW_SIDE
				BEQ	GOT_THE_SIDE
:SKIPB			JSR	TURN_OFF
				LDA	DISK_SIDE
				JSR	ASK_FOR_SIDE
				JMP	GET_SLOW_SIDE

				NOP					; *** FREE SPACE

SLOW_SIDE		STX	DRIVENUM
				TXA
				ORA	SLOT_X0
				TAX
				STA	DRIVE1,X
				JSR	UP_TO_SPEED
				JSR	FIND_SIDE
				LDX	DRIVENUM
				STA	IN_DRIVE1,X
				CMP	DISK_SIDE
				RTS

GOT_THE_SIDE	LDA	TRACK_FOUND
				ASL
				STA	TRACK
				LDA	STRACK
				ASL
				JMP	ARMOVE

FIND_SIDE		LDA	#RECALIBS
				STA	ECOUNT1
				LDA	#$FF
				STA	SECTOR
:LOOP0			LDA	#RETRIES
				STA	ECOUNT2
:LOOP1			JSR	READ_ADDRESS
				BCC	:SKIPA
				DEC	ECOUNT2
				BNE	:LOOP1
				DEC	ECOUNT1
				BMI	:ERROR
				LDA	#$88
				STA	TRACK
				LDA	#$00
				JSR	ARMOVE
				JMP	:LOOP0
:ERROR			LDA	#$FF
				RTS
:SKIPA			LDA	SIDE_FOUND
				RTS

UP_TO_SPEED		LDX	SLOT_X0
				STA	DRIVEON,X
				LDA	#$D8
				STA	MOTCNTH
				LDA	LATCHIN,X
				LDA	READER,X
				LDY	#$08
TIMER			LDA	READER,X
				PHA
				PLA
				PHA
				PLA
				STX	HOLDC
				CMP	READER,X
				BNE	AT_SPEED
				DEY
				BNE	TIMER
				LDY	MOTCNTH
				BPL	AT_SPEED
DEL12			LDY	#$12
DELSPED			DEY
				BNE	DELSPED
				INC	MOTCNTL
				BNE	DEL12
				INC	MOTCNTH
				BNE	DEL12
AT_SPEED		RTS

HOLDC			DB	$00                          ;*** move this

; TODO: CODETAB access always incurs a page crossing
;   cycle penalty.  Is this timing issue being depended on?
CODETAB			=	*-$96
				DB	$00,$01,$98
				DB	$99,$02,$03
				DB	$9C,$04,$05
				DB	$06,$A0,$A1
				DB	$A2,$A3,$A4
				DB	$A5,$07,$08
				DB	$A8,$A9,$AA
				DB	$09,$0A,$0B
				DB	$0C,$0D,$B0
				DB	$B1,$0E,$0F
				DB	$10,$11,$12
				DB	$13,$B8,$14
				DB	$15,$16,$17
				DB	$18,$19,$1A
				DB	$C0,$C1,$C2
				DB	$C3,$C4,$C5
				DB	$C6,$C7,$C8
				DB	$C9,$CA,$1B
				DB	$CC,$1C,$1D
				DB	$1E,$D0,$D1
				DB	$D2,$1F,$D4
				DB	$D5,$20,$21
				DB	$D8,$22,$23
				DB	$24,$25,$26
				DB	$27,$28,$E0
				DB	$E1,$E2,$E3
				DB	$E4,$29,$2A
				DB	$2B,$E8,$2C
				DB	$2D,$2E,$2F
				DB	$30,$31,$32
				DB	$F0,$F1,$33
				DB	$34,$35,$36
				DB	$37,$38,$F8
				DB	$39,$3A,$3B
				DB	$3C,$3D,$3E
				DB	$3F
;               SAME_PAGE_AS_ CODETAB

; physical to logical
INTERLEAVE_P2L  DB	$00,$08,$01,$09,$02,$0A,$03,$0B
				DB	$04,$0C,$05,$0D,$06,$0E,$07,$0F

ARMOVE			LDX	SLOT_X0
				STA	HOLDD
				CMP	TRACK
				BEQ	MOVDONE
				LDA	#$EF
				STA	MOTCNTL
				LDA	#$D8
				STA	MOTCNTH
				LDA	#$00
				STA	HOLDA
NOTDONE			LDA	TRACK
				STA	HOLDB
				SEC
				SBC	HOLDD
				BEQ	EQUAL
				BCS	POSITIV
				EOR	#$FF
				INC	TRACK
				BCC	NOADD
POSITIV			ADC	#$FE
				DEC	TRACK
NOADD			CMP	HOLDA
				BCC	NOLOAD
				LDA	HOLDA
NOLOAD			CMP	#$0C
				BCS	NOTRANS
				TAY
NOTRANS			SEC
				JSR	HALFSUB
				LDA	DELAYS,Y
				JSR	DELAYER
				LDA	HOLDB
				CLC
				JSR	HALF2
				LDA	DELAYS2,Y
				JSR	DELAYER
				INC	HOLDA
				BNE	NOTDONE
EQUAL			JSR	DELAYER
				CLC
HALFSUB			LDA	TRACK
HALF2			AND	#$03
				ROL
				ORA	SLOT_X0
				TAX
				LDA	ARM,X
				LDX	SLOT_X0
MOVDONE			RTS

DELAYER			LDX	#$11
DELOOP			DEX
				BNE	DELOOP
				INC	MOTCNTL
				BNE	NOCARRY
				INC	MOTCNTH
NOCARRY			SEC
				SBC	#$01
				BNE	DELAYER
				SAME_PAGE_AS_ DELAYER
				RTS

DELAYS2			DB	$70,$2C,$26
				DB	$22,$1F,$1E
				DB	$1D,$1C,$1C
				DB	$1C,$1C,$1C
                SAME_PAGE_AS_ DELAYS2

DELAYS			DB	$01,$30,$28
				DB	$24,$20,$1E
				DB	$1D,$1C,$1C
				DB	$1C,$1C,$1C
                SAME_PAGE_AS_ DELAYS
;
; On entry:
;	X: file hook address low
;	Y: file hook address high
;
SET_FILE_HOOK	ENT
				STX TO_FILE_HOOK+1
				STY TO_FILE_HOOK+2
				RTS

UN_WRITE_PRO	SEC
				BCS TO_FILE_HOOK		; always
ASK_FOR_SIDE	CLC
TO_FILE_HOOK	JMP	DEFAULT_HOOK		; modified
DEFAULT_HOOK	RTS
;
; On entry:
;	A: new disk side
;
; On exit:
;	X: unchanged
;	Y: unchanged
;
SET_DISK_SIDE	ENT
				STA DISK_SIDE
				RTS
;
; On entry:
;   A: disk controller slot number * 16
;
SET_SLOT_X0     ENT
                STA SLOT_X0
                RTS

TRACK			DS	1
SECTOR			DS	1
SECHOLD			DS	1
SECOUNT			DS	1
DRIVENUM		DS	1

CHECKSUM_FOUND	DS	1				; order dependent
SECTOR_FOUND	DS	1				;
TRACK_FOUND		DS	1				;
SIDE_FOUND		DS	1				;

ECOUNT1			DS	1
ECOUNT2			DS	1

IN_DRIVE1		DB	$00				;Must be consecutive
IN_DRIVE2		DB	$FF				;  in this order

NUM_DRIVES		DB	$01				;TEMP***
SLOT_X0			DB	$60				;TEMP***

				DS	$800-3-*

ON_OFF_FLAG		DB	$00
LAST1			DB	$00
SSTOREL			DB	$00
